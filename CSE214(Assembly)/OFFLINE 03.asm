TITLE PGM4_1.5: SAMPLE INPUT
.MODEL SMALL
.STACK 100H
.DATA
DIVISOR DW ?
TOTAL DW ? 
VAR1 DW ?
.CODE
MAIN PROC
     
    MOV AX,@DATA
    MOV DS,AX  
    
    LOOP_STARTED:
    CALL INPUT
      
 
     
    CALL SERIES_SUM 
    
    MOV AX, CX  ; AS OUTPUT IS SHOWN FROM AX
    CALL OUTPUT
    
     
    JMP LOOP_STARTED 
    
    
    LOOP_END:
    
    MOV AH,4CH
    INT 21H  
MAIN ENDP

; THIS PROC WILL RETURN A MEMBER OF  SERIES
; INPUT AX HOLDS  THE NTH TERM WHICH HAS TO BE FIND
; OUTPUT WILL BE IN CX
; USED INSIDE OF SERIES_SUM PROC
    
    
GEN_SERIES PROC
    
    
    PUSH AX
    PUSH BX
    
    PUSH DX
    CMP AX,0
    JNE BASE1  ; BASE CASE FOR 0
    MOV CX,3 
    POP DX
    POP BX
    POP AX
    RET
    
    BASE1:      ; BASE CASE FOR 1
    CMP AX,1
    JNE BASE2
    MOV CX,6 
    POP DX
    POP BX
    POP AX
    RET 
    BASE2:       ; BASE CASE FOR 2
    CMP AX,2
    JNE NOT_BASE
    MOV CX,4 
    POP DX
    POP BX
    POP AX
    RET 
    
    NOT_BASE:       ; IF IT IS NOT BASE CASE
    
      
    
    DEC AX            ; CALLING N-1
    CALL GEN_SERIES
    
    MOV BX,CX          
    DEC AX
    CALL GEN_SERIES      ; CALLING N-2
    ADD BX,CX            ; ADDING WITH PREVIOUS ONE
    DEC AX
    CALL GEN_SERIES      ; CALLING N-3
    ADD BX,CX            ; ADDING WITH PREVIOUS ONE
    
    MOV CX,BX            ; MOVING THE RESULT TO CX
    SUB CX,5             ; SUBTRACTING 5 AS FUNCTION
    
                                         
    POP DX
    POP BX
    POP AX
    RET 
    
GEN_SERIES ENDP  

; THIS PROC WILL FIND SUM OF  SERIES
; INPUT WILL BE N THE NUMBER OF TERMS WILL BE STORED IN AX
; OUTPUT IS THE SUM IN CX
; USED INSIDE MAIN PROC

SERIES_SUM PROC 
    
    
    
    PUSH AX
    PUSH BX
    
    PUSH DX
    
    MOV DX,0   
    SUB AX,1
    
    
    
    WHILE:  
        CMP AX,0            ;COMPARING IS IT END
        JBE END_WHILE
    
   
         CALL GEN_SERIES    ; GETTING THE NUMBER
         ADD DX,CX          ; ADDING IN ACCUMULATOR
         DEC AX             ; DECREASING THE NUMBER WHICH TO BE FOND
        JMP WHILE
    END_WHILE:
    CALL GEN_SERIES         ; CALLING FOR THE 0;TH TERM
    ADD DX,CX               ; ADDING WITH RESULT
    MOV CX,DX               ; RESULT IS MOVING TO CX
    POP DX
    
    POP BX
    POP AX 
    
   
        
  
    RET
SERIES_SUM ENDP 


; THIS PROC TAKES INPUT FROM SCREEN UNTILL A ENTER IS READ
; NO INPUT IS REQUIRED
; OUTPUT WILL BE IN AX
; USED INSIDE MAIN PROC
INPUT PROC  
    
    PUSH BX
    PUSH CX
    PUSH DX
    PUSH TOTAL
    
    MOV TOTAL,0
     
   INPUT1_LOOP_CONDITION: 
 
   MOV AH,1
   INT 21H 
   CMP AL, 0DH  ;IF ENTER THEN TERMINATE
   JE INPUT1_END  
   CMP AL,1AH
   JE LOOP_END
   ;JMP INPUT1_LOOP
   INPUT1_LOOP:
   ;CMP AL,1AH   ; CHECKING EOF
   ;JE OUT_OF_THE_LOOP 
   MOV AH,0     ;CLEARING TO STORE IN VAR1
   MOV VAR1,AX  ; MOVING TO VAR1 AS AX WILL BE USED LATER
   SUB VAR1,'0' ; EXTRACTING NUMBER
   MOV AL,10    ; MULTIPLICATOR
   MUL TOTAL    ; MULTIPLICATION 
   ADD AX,VAR1  ; ADDING EXTRACTED NUMBER
   MOV TOTAL,AX ; READY FOR NEXT
   JMP INPUT1_LOOP_CONDITION  
   INPUT1_END: 
   MOV AX,TOTAL ;AS PROHIBITED  
   PUSH AX
   
   ;INPUT1_END   
   MOV DL,0DH
   MOV AH,2
   INT 21H
   MOV DL,0AH
   INT 21H
   POP AX
   POP TOTAL
   POP DX
   POP CX
   POP BX
   RET
INPUT ENDP

; THIS PROC SHOWS THE OUTPUT  IN DECIMAL
; INPUT WILL BE IN AX THE NUMBER TO BE SHOWED
; NO OUTPUT
; USED INSIDE MAIN PROC

OUTPUT PROC 
    
    
   PUSH AX
   PUSH BX
   PUSH CX
   PUSH DX
   PUSH TOTAL
   PUSH VAR1
    
    
   MOV DX,0             ;CLEARING DX
   MOV DIVISOR,10       ;SETTING DIVISOR
   MOV CX,10000         ;SETTING DIVISOR TO DIVIDE THE OUTPUT
   FIRST_DIVISION:
   DIV CX                ;DIVISION  UNTIL A NUMBER EXCEPT ZERO
   CMP AX,0              ; CHECKING IF THE QUOTIENT IS ZERO
   JNE SECOND_DIVISION
   MOV VAR1,DX           ;SAVING REMAINDER
   MOV DX,0              ;CLEARING DX
   MOV AX,CX             ;MOVING CX TO AX TO DIVIDE
   DIV DIVISOR           ;DIVIDING BY 10
   MOV CX,AX             ;MOVING QUOTIENT TO DIVISOR
   MOV AX,VAR1           ; NOW AX HOLDS THE VALUE OF REMAINDER OF THE  DIVISION OF THE RESULT
   JMP FIRST_DIVISION    ;REPEAT
   SECOND_DIVISION:      ;NOW WE GOT A NONZERO DIGIT
   MOV VAR1,DX           ;STORING REMAINDER TO CONTINUE PROCESS
   MOV DL,AL             ;PRESENTATION PROCEDURE
   ADD DL,'0'
   MOV AH,2
   INT 21H
   
   MOV DX,0              ;CLEARING DX FOR NEXT DIVISION
   MOV AX,CX             ;MOVING CX TO AX TO DIVIDE BY 10
   DIV DIVISOR           ;DIVIDING
   MOV CX,AX             ;STORING QUOTIENT
   CMP CX,0              ;CHECKING IF ZERO
   JE END_OF_OUTPUT      ;IF NOT CONTINUE
   MOV DX,0              ;CLEARING DX FOR NEXT DIVISION
   MOV AX,VAR1           ;NOW WE HAVE REMANDER OF OUTPUT DIVISION
   DIV CX                ;DIVIDING
   JMP SECOND_DIVISION   ;REPEAT
   END_OF_OUTPUT:        ;END    
   
   
   MOV DL,0DH   
   MOV AH,2
   INT 21H
   MOV DL,0AH
   INT 21H
   
   
   POP VAR1
   POP TOTAL
   POP DX
   POP CX
   POP BX
   POP AX
   
          
   RET 
   
   
OUTPUT ENDP

    
    END MAIN